<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>åŠ›æ‰£ 912 å †æ’åºåŒè§†å›¾å¯è§†åŒ–</title>
<style>
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    margin: 20px;
    background: #f0f0f0;
  }
  h1 {
    text-align: center;
  }
  #inputArea {
    margin-bottom: 10px;
    text-align: center;
  }
  #arrayInput {
    width: 280px;
    font-size: 16px;
    padding: 5px;
  }
  label {
    font-weight: bold;
  }
  #intervalInput {
    width: 50px;
    font-size: 16px;
    padding: 3px;
    margin-left: 10px;
  }
  button {
    font-size: 16px;
    padding: 6px 12px;
    margin-left: 10px;
    cursor: pointer;
  }
  #mainArea {
    display: flex;
    justify-content: center;
    gap: 40px;
    margin-bottom: 20px;
  }
  /* ç›´æ–¹å›¾å®¹å™¨ */
  #arrayContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 45%;
    height: 200px;
  }
  #barsContainer {
    display: flex;
    justify-content: center;
    align-items: flex-end;
    gap: 5px;
    height: 160px;
    width: 100%;
  }
  .bar {
    width: 30px;
    background: steelblue;
    color: white;
    text-align: center;
    border-radius: 4px 4px 0 0;
    user-select: none;
    font-weight: bold;
    font-size: 14px;
    position: relative;
  }
  .bar.highlight {
    background: orangered;
  }
  .bar.swapping {
    background: orange;
  }
  #info {
    text-align: center;
    font-size: 18px;
    margin-top: 10px;
    min-height: 24px;
  }
  /* å †æ ‘å½¢ç»“æ„SVGå®¹å™¨ */
  #heapTreeContainer {
    width: 45%;
    border: 1px solid #ccc;
    border-radius: 6px;
    background: white;
    padding: 10px;
    box-sizing: border-box;
  }
  #heapTreeSVG {
    width: 100%;
    height: 220px;
  }
  /* èŠ‚ç‚¹æ ·å¼ */
  .node circle {
    fill: steelblue;
    stroke: #333;
    stroke-width: 1.5px;
    cursor: default;
  }
  .node text {
    fill: white;
    font-weight: bold;
    font-size: 14px;
    pointer-events: none;
  }
  .node.highlight circle {
    fill: orangered;
  }
  .node.swapping circle {
    fill: orange;
  }
  /* çº¿æ¡ */
  line.edge {
    stroke: #999;
    stroke-width: 1.5px;
  }
  /* æ—¥å¿— */
  #logContainer {
    background: #111;
    color: #eee;
    font-family: monospace;
    height: 200px;
    overflow-y: auto;
    padding: 10px;
    border-radius: 6px;
    white-space: pre-line;
    max-width: 900px;
    margin: 0 auto 20px auto;
  }
  #footer {
    margin-top: 10px;
    text-align: center;
  }
  #footer a {
    text-decoration: none;
    color: #3366cc;
    font-weight: bold;
  }
</style>
</head>
<body>
<h1>åŠ›æ‰£ 912 - å †æ’åºç®—æ³•åŒè§†å›¾å¯è§†åŒ–</h1>

<div id="inputArea">
  <label>æ•°ç»„ï¼ˆé€—å·åˆ†éš”ï¼‰ï¼š</label>
  <input id="arrayInput" type="text" value="4,10,3,5,1,8,7,9" />
  <label>åŠ¨ç”»é—´éš”(s)ï¼š</label>
  <input id="intervalInput" type="number" min="0.1" step="0.1" value="1" />
  <button id="startBtn">å¼€å§‹å¯è§†åŒ–</button>
</div>

<div id="mainArea">
  <div id="arrayContainer">
    <div id="barsContainer"></div>
    <div id="info"></div>
  </div>
  <div id="heapTreeContainer">
    <svg id="heapTreeSVG"></svg>
  </div>
</div>

<div id="logContainer"></div>

<div id="footer">
  <a href="index.html">ã€è¿”å›é¦–é¡µã€‘</a>
</div>

<script>
  const arrayInput = document.getElementById("arrayInput");
  const intervalInput = document.getElementById("intervalInput");
  const startBtn = document.getElementById("startBtn");
  const barsContainer = document.getElementById("barsContainer");
  const info = document.getElementById("info");
  const logContainer = document.getElementById("logContainer");
  const heapTreeSVG = document.getElementById("heapTreeSVG");

  let nums = [];
  let animationInterval = 1000;
  let timer = null;
  let steps = [];
  let stepIndex = 0;

  // æ¸²æŸ“ç›´æ–¹å›¾
  function renderArray(arr, highlightIndices = [], swappingIndices = []) {
    barsContainer.innerHTML = "";
    const maxVal = Math.max(...arr, 10);
    arr.forEach((num, idx) => {
      const bar = document.createElement("div");
      bar.classList.add("bar");
      bar.style.height = (num / maxVal) * 150 + 30 + "px";
      bar.textContent = num;

      if (highlightIndices.includes(idx)) {
        bar.classList.add("highlight");
      }
      if (swappingIndices.includes(idx)) {
        bar.classList.add("swapping");
      }

      barsContainer.appendChild(bar);
    });
  }

  // æ—¥å¿—æ‰“å°
  function log(text) {
    logContainer.textContent += text + "\n";
    logContainer.scrollTop = logContainer.scrollHeight;
  }

  // è®°å½•æ­¥éª¤
  function recordStep(arr, infoText, highlight = [], swapping = []) {
    steps.push({
      arr: arr.slice(),
      info: infoText,
      highlight,
      swapping,
    });
  }

  // ç»˜åˆ¶å †æ ‘ç»“æ„
  function renderHeapTree(arr, highlight = [], swapping = []) {
    // æ¸…ç©ºSVG
    while (heapTreeSVG.firstChild) {
      heapTreeSVG.removeChild(heapTreeSVG.firstChild);
    }

    if (arr.length === 0) return;

    const width = heapTreeSVG.clientWidth;
    const height = heapTreeSVG.clientHeight;

    // è®¡ç®—æ¯å±‚æœ€å¤§èŠ‚ç‚¹æ•°
    // å±‚æ•° = floor(log2(n)) + 1
    const n = arr.length;
    const levels = Math.floor(Math.log2(n)) + 1;

    // æ¯å±‚èŠ‚ç‚¹æ¨ªåæ ‡é—´è·è®¡ç®—ï¼ˆæ ¹æ®å±‚å®½åº¦ï¼‰
    // æ ¹èŠ‚ç‚¹å±…ä¸­, æ¯å±‚é—´è·é€’å‡
    // ç”¨é€’å½’æˆ–å¾ªç¯æ”¾ç½®èŠ‚ç‚¹å¹¶ç”»çº¿

    // é€’å½’ç»˜åˆ¶èŠ‚ç‚¹å’Œè¾¹
    function drawNode(index, level, x) {
      const nodeRadius = 15;
      const yGap = 50;
      const y = yGap * level + 20;

      // èŠ‚ç‚¹åœ†
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", x);
      circle.setAttribute("cy", y);
      circle.setAttribute("r", nodeRadius);
      circle.setAttribute("class", "node-circle");

      // åˆ¤æ–­é«˜äº®å’Œäº¤æ¢çŠ¶æ€ï¼Œæ”¹é¢œè‰²
      if (highlight.includes(index)) {
        circle.classList.add("highlight");
      }
      if (swapping.includes(index)) {
        circle.classList.add("swapping");
      }

      // èŠ‚ç‚¹æ–‡æœ¬
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", x);
      text.setAttribute("y", y + 5);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("pointer-events", "none");
      text.setAttribute("class", "node-text");
      text.textContent = arr[index];

      // åŒ…è£¹groupæ–¹ä¾¿ç®¡ç†
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.setAttribute("class", "node");
      if (highlight.includes(index)) group.classList.add("highlight");
      if (swapping.includes(index)) group.classList.add("swapping");

      group.appendChild(circle);
      group.appendChild(text);

      heapTreeSVG.appendChild(group);

      // ç”»è¿æ¥çº¿åˆ°å·¦å³å­èŠ‚ç‚¹
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;

      const xGap = width / Math.pow(2, level + 2); // æ¨ªå‘åˆ†å¸ƒè·ç¦»æ§åˆ¶

      if (leftChild < n) {
        const childX = x - xGap;
        const childY = y + yGap;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x);
        line.setAttribute("y1", y + nodeRadius);
        line.setAttribute("x2", childX);
        line.setAttribute("y2", childY - nodeRadius);
        line.setAttribute("class", "edge");
        heapTreeSVG.appendChild(line);

        drawNode(leftChild, level + 1, childX);
      }
      if (rightChild < n) {
        const childX = x + xGap;
        const childY = y + yGap;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x);
        line.setAttribute("y1", y + nodeRadius);
        line.setAttribute("x2", childX);
        line.setAttribute("y2", childY - nodeRadius);
        line.setAttribute("class", "edge");
        heapTreeSVG.appendChild(line);

        drawNode(rightChild, level + 1, childX);
      }
    }

    // ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œæ°´å¹³å±…ä¸­ç»˜åˆ¶
    drawNode(0, 0, width / 2);
  }

  // å †æ’åºè¿‡ç¨‹ï¼Œè®°å½•æ­¥éª¤
  function heapSortWithSteps(arr) {
    steps = [];
    const n = arr.length;

    recordStep(arr, `åˆå§‹æ•°ç»„ï¼š${arr.join(", ")}`);

    // å»ºå †
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
      recordStep(arr, `å¼€å§‹ heapifyï¼ŒrootIndex = ${i}`, [i]);
      heapify(arr, n, i);
    }
    recordStep(arr, `æœ€å¤§å †æ„å»ºå®Œæˆ`);

    // æ’åº
    for (let i = n - 1; i > 0; i--) {
      recordStep(arr, `äº¤æ¢å †é¡¶ nums[0]=${arr[0]} å’Œæœ«å°¾ nums[${i}]=${arr[i]}`, [0], [i]);
      swap(arr, 0, i);
      recordStep(arr, `äº¤æ¢å®Œæˆï¼Œheapify è°ƒæ•´å †ï¼ŒheapSize=${i}`, [0]);
      heapify(arr, i, 0);
    }
    recordStep(arr, `æ’åºå®Œæˆï¼Œæœ€ç»ˆæ•°ç»„ï¼š${arr.join(", ")}`);
  }

  function heapify(arr, heapSize, rootIndex) {
    let largest = rootIndex;
    const left = 2 * rootIndex + 1;
    const right = 2 * rootIndex + 2;

    if (left < heapSize && arr[left] > arr[largest]) {
      largest = left;
    }
    if (right < heapSize && arr[right] > arr[largest]) {
      largest = right;
    }

    if (largest !== rootIndex) {
      recordStep(arr, `heapify: äº¤æ¢ nums[${rootIndex}]=${arr[rootIndex]} å’Œ nums[${largest}]=${arr[largest]}`, [rootIndex, largest], [rootIndex, largest]);
      swap(arr, rootIndex, largest);
      heapify(arr, heapSize, largest);
    } else {
      recordStep(arr, `heapify: ä½ç½® ${rootIndex} æ»¡è¶³æœ€å¤§å †ï¼Œæ— éœ€äº¤æ¢`, [rootIndex]);
    }
  }

  function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }

  // æ’­æ”¾åŠ¨ç”»
  function playAnimation() {
    if (stepIndex >= steps.length) {
      info.textContent = "æ’åºå®Œæˆ ğŸ‰";
      startBtn.disabled = false;
      return;
    }
    const step = steps[stepIndex];
    renderArray(step.arr, step.highlight, step.swapping);
    renderHeapTree(step.arr, step.highlight, step.swapping);
    info.textContent = step.info;
    log(step.info);
    stepIndex++;
    timer = setTimeout(playAnimation, animationInterval);
  }

  startBtn.onclick = () => {
    const raw = arrayInput.value.trim();
    if (!raw) {
      alert("è¯·è¾“å…¥æ•°ç»„ï¼Œç”¨é€—å·åˆ†éš”");
      return;
    }
    const arr = raw.split(",").map(x => Number(x.trim())).filter(x => !isNaN(x));
    if (arr.length === 0) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—æ•°ç»„");
      return;
    }
    nums = arr;

    let intervalVal = Number(intervalInput.value);
    if (isNaN(intervalVal) || intervalVal <= 0) {
      intervalVal = 1;
      intervalInput.value = "1";
    }
    animationInterval = intervalVal * 1000;

    stepIndex = 0;
    logContainer.textContent = "";
    info.textContent = "å‡†å¤‡å¼€å§‹...";
    renderArray(nums);
    renderHeapTree(nums);

    startBtn.disabled = true;
    heapSortWithSteps(nums.slice());

    setTimeout(() => {
      logContainer.textContent = "";
      stepIndex = 0;
      playAnimation();
    }, 300);
  };

  // åˆå§‹åŒ–æ¸²æŸ“é»˜è®¤æ•°ç»„
  renderArray([4, 10, 3, 5, 1, 8, 7, 9]);
  renderHeapTree([4, 10, 3, 5, 1, 8, 7, 9]);
</script>
</body>
</html>
